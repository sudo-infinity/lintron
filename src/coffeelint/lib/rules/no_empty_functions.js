// Generated by CoffeeScript 1.7.1
(function() {
  var NoEmptyFunctions, isEmptyCode;

  isEmptyCode = function(node, astApi) {
    var nodeName;
    nodeName = astApi.getNodeName(node);
    return nodeName === 'Code' && node.body.isEmpty();
  };

  module.exports = NoEmptyFunctions = (function() {
    function NoEmptyFunctions() {}

    NoEmptyFunctions.prototype.rule = {
      name: 'no_empty_functions',
      level: 'ignore',
      message: 'Empty function',
      description: "Disallows declaring empty functions. The goal of this rule is that\nunintentional empty callbacks can be detected:\n<pre>\n<code>someFunctionWithCallback ->\ndoSomethingSignificant()\n</code>\n</pre>\nThe problem is that the call to\n<tt>doSomethingSignificant</tt> will be made regardless\nof <tt>someFunctionWithCallback</tt>'s execution. It can\nbe because you did not indent the call to\n<tt>doSomethingSignificant</tt> properly.\n\nIf you really meant that <tt>someFunctionWithCallback</tt>\nshould call a callback that does nothing, you can write your code\nthis way:\n<pre>\n<code>someFunctionWithCallback ->\n    undefined\ndoSomethingSignificant()\n</code>\n</pre>"
    };

    NoEmptyFunctions.prototype.lintAST = function(node, astApi) {
      this.lintNode(node, astApi);
      return void 0;
    };

    NoEmptyFunctions.prototype.lintNode = function(node, astApi) {
      var error;
      if (isEmptyCode(node, astApi)) {
        error = astApi.createError({
          lineNumber: node.locationData.first_line + 1
        });
        this.errors.push(error);
      }
      return node.eachChild((function(_this) {
        return function(child) {
          return _this.lintNode(child, astApi);
        };
      })(this));
    };

    return NoEmptyFunctions;

  })();

}).call(this);
