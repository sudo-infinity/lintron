// Generated by CoffeeScript 1.7.1
(function() {
  var MissingFatArrows, any, containsButIsnt,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  any = function(arr, test) {
    return arr.reduce((function(res, elt) {
      return res || test(elt);
    }), false);
  };

  containsButIsnt = function(node, nIsThis, nIsClass) {
    var target;
    target = void 0;
    node.traverseChildren(false, function(n) {
      if (nIsClass(n)) {
        return false;
      }
      if (nIsThis(n)) {
        target = n;
        return false;
      }
    });
    return target;
  };

  module.exports = MissingFatArrows = (function() {
    function MissingFatArrows() {
      this.isFatArrowCode = __bind(this.isFatArrowCode, this);
      this.isThis = __bind(this.isThis, this);
      this.isObject = __bind(this.isObject, this);
      this.isValue = __bind(this.isValue, this);
      this.isClass = __bind(this.isClass, this);
      this.isCode = __bind(this.isCode, this);
    }

    MissingFatArrows.prototype.rule = {
      name: 'missing_fat_arrows',
      level: 'ignore',
      is_strict: false,
      message: 'Used `this` in a function without a fat arrow',
      description: "Warns when you use `this` inside a function that wasn't defined\nwith a fat arrow. This rule does not apply to methods defined in a\nclass, since they have `this` bound to the class instance (or the\nclass itself, for class methods). The option `is_strict` is\navailable for checking bindings of class methods.\n\nIt is impossible to statically determine whether a function using\n`this` will be bound with the correct `this` value due to language\nfeatures like `Function.prototype.call` and\n`Function.prototype.bind`, so this rule may produce false positives."
    };

    MissingFatArrows.prototype.lintAST = function(node, astApi) {
      this.astApi = astApi;
      this.lintNode(node);
      return void 0;
    };

    MissingFatArrows.prototype.lintNode = function(node, methods) {
      var error, is_strict, _ref;
      if (methods == null) {
        methods = [];
      }
      is_strict = (_ref = this.astApi.config[this.rule.name]) != null ? _ref.is_strict : void 0;
      if (this.isConstructor(node)) {
        return;
      }
      if ((!this.isFatArrowCode(node)) && (is_strict ? true : __indexOf.call(methods, node) < 0) && (this.needsFatArrow(node))) {
        error = this.astApi.createError({
          lineNumber: node.locationData.first_line + 1
        });
        this.errors.push(error);
      }
      return node.eachChild((function(_this) {
        return function(child) {
          return _this.lintNode(child, (function() {
            switch (false) {
              case !this.isClass(node):
                return this.methodsOfClass(node);
              case !this.isCode(node):
                return [];
              default:
                return methods;
            }
          }).call(_this));
        };
      })(this));
    };

    MissingFatArrows.prototype.isCode = function(node) {
      return this.astApi.getNodeName(node) === 'Code';
    };

    MissingFatArrows.prototype.isClass = function(node) {
      return this.astApi.getNodeName(node) === 'Class';
    };

    MissingFatArrows.prototype.isValue = function(node) {
      return this.astApi.getNodeName(node) === 'Value';
    };

    MissingFatArrows.prototype.isObject = function(node) {
      return this.astApi.getNodeName(node) === 'Obj';
    };

    MissingFatArrows.prototype.isThis = function(node) {
      return this.isValue(node) && node.base.value === 'this';
    };

    MissingFatArrows.prototype.isFatArrowCode = function(node) {
      return this.isCode(node) && node.bound;
    };

    MissingFatArrows.prototype.isConstructor = function(node) {
      var _ref;
      return ((_ref = node.variable) != null ? _ref.base.value : void 0) === 'constructor';
    };

    MissingFatArrows.prototype.needsFatArrow = function(node) {
      return this.isCode(node) && (any(node.params, (function(_this) {
        return function(param) {
          return param.contains(_this.isThis) != null;
        };
      })(this)) || containsButIsnt(node.body, this.isThis, this.isClass));
    };

    MissingFatArrows.prototype.methodsOfClass = function(classNode) {
      var bodyNodes, returnNode;
      bodyNodes = classNode.body.expressions;
      returnNode = bodyNodes[bodyNodes.length - 1];
      if ((returnNode != null) && this.isValue(returnNode) && this.isObject(returnNode.base)) {
        return returnNode.base.properties.map(function(assignNode) {
          return assignNode.value;
        }).filter(this.isCode);
      } else {
        return [];
      }
    };

    return MissingFatArrows;

  })();

}).call(this);
