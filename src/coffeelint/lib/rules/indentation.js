// Generated by CoffeeScript 1.7.1
(function() {
  var Indentation;

  module.exports = Indentation = (function() {
    Indentation.prototype.rule = {
      name: 'indentation',
      value: 2,
      level: 'error',
      message: 'Line contains inconsistent indentation',
      description: "This rule imposes a standard number of spaces to be used for\nindentation. Since whitespace is significant in CoffeeScript, it's\ncritical that a project chooses a standard indentation format and\nstays consistent. Other roads lead to darkness. <pre> <code>#\nEnabling this option will prevent this ugly\n# but otherwise valid CoffeeScript.\ntwoSpaces = () ->\n  fourSpaces = () ->\n      eightSpaces = () ->\n            'this is valid CoffeeScript'\n\n</code>\n</pre>\nTwo space indentation is enabled by default."
    };

    Indentation.prototype.tokens = ['INDENT', '[', ']', '.'];

    function Indentation() {
      this.arrayTokens = [];
    }

    Indentation.prototype.lintToken = function(token, tokenApi) {
      var currentLine, expected, ignoreIndent, isArrayIndent, isInterpIndent, isMultiline, lineNumber, lines, numIndents, previous, previousSymbol, type, _ref, _ref1, _ref2;
      type = token[0], numIndents = token[1], (_ref = token[2], lineNumber = _ref.first_line);
      lines = tokenApi.lines, lineNumber = tokenApi.lineNumber;
      expected = tokenApi.config[this.rule.name].value;
      if (type === '.') {
        currentLine = lines[lineNumber];
        if (((_ref1 = currentLine.match(/\S/i)) != null ? _ref1[0] : void 0) === '.') {
          return this.handleChain(tokenApi, expected);
        }
        return void 0;
      }
      if (type === '[' || type === ']') {
        this.lintArray(token);
        return void 0;
      }
      if (token.generated != null) {
        return null;
      }
      previous = tokenApi.peek(-2);
      isInterpIndent = previous && previous[0] === '+';
      previous = tokenApi.peek(-1);
      isArrayIndent = this.inArray() && (previous != null ? previous.newLine : void 0);
      previousSymbol = (_ref2 = tokenApi.peek(-1)) != null ? _ref2[0] : void 0;
      isMultiline = previousSymbol === '=' || previousSymbol === ',';
      ignoreIndent = isInterpIndent || isArrayIndent || isMultiline;
      numIndents = this.getCorrectIndent(tokenApi);
      if (!ignoreIndent && numIndents !== expected) {
        return {
          context: "Expected " + expected + " got " + numIndents
        };
      }
    };

    Indentation.prototype.inArray = function() {
      return this.arrayTokens.length > 0;
    };

    Indentation.prototype.lintArray = function(token) {
      if (token[0] === '[') {
        this.arrayTokens.push(token);
      } else if (token[0] === ']') {
        this.arrayTokens.pop();
      }
      return null;
    };

    Indentation.prototype.handleChain = function(tokenApi, expected) {
      var callStart, checkNum, currIsIndent, currentLine, currentSpaces, findCallStart, lastCheck, lineNumber, lines, numIndents, prevIsIndent, prevLine, prevNum, prevSpaces, _ref, _ref1;
      lastCheck = 1;
      callStart = 1;
      prevNum = 1;
      lineNumber = tokenApi.lineNumber, lines = tokenApi.lines;
      currentLine = lines[lineNumber];
      findCallStart = tokenApi.peek(-callStart);
      while (findCallStart && findCallStart[0] !== 'TERMINATOR') {
        lastCheck = findCallStart[2].first_line;
        callStart += 1;
        findCallStart = tokenApi.peek(-callStart);
      }
      while ((lineNumber - prevNum > lastCheck) && !/^\s*\./.test(lines[lineNumber - prevNum])) {
        prevNum += 1;
      }
      checkNum = lineNumber - prevNum;
      if (checkNum >= 0) {
        prevLine = lines[checkNum];
        if (prevLine.match(/\S/i)[0] === '.' || checkNum === lastCheck) {
          currentSpaces = (_ref = currentLine.match(/\S/i)) != null ? _ref.index : void 0;
          prevSpaces = (_ref1 = prevLine.match(/\S/i)) != null ? _ref1.index : void 0;
          numIndents = currentSpaces - prevSpaces;
          prevIsIndent = prevSpaces % expected !== 0;
          currIsIndent = currentSpaces % expected !== 0;
          if (prevIsIndent && currIsIndent) {
            numIndents = currentSpaces;
          }
          if (numIndents % expected !== 0) {
            return {
              context: "Expected " + expected + " got " + numIndents
            };
          }
        }
      }
    };

    Indentation.prototype.getCorrectIndent = function(tokenApi) {
      var curIndent, i, lineNumber, lines, prevIndent, prevLine, prevNum, tokens, _ref, _ref1, _ref2;
      lineNumber = tokenApi.lineNumber, lines = tokenApi.lines, tokens = tokenApi.tokens, i = tokenApi.i;
      curIndent = (_ref = lines[lineNumber].match(/\S/)) != null ? _ref.index : void 0;
      prevNum = 1;
      while (/^\s*(#|$)/.test(lines[lineNumber - prevNum])) {
        prevNum += 1;
      }
      prevLine = lines[lineNumber - prevNum];
      prevIndent = (_ref1 = prevLine.match(/^(\s*)\./)) != null ? _ref1[1].length : void 0;
      if (prevIndent > 0) {
        return curIndent - ((_ref2 = prevLine.match(/\S/)) != null ? _ref2.index : void 0);
      } else {
        return tokens[i][1];
      }
    };

    return Indentation;

  })();

}).call(this);
