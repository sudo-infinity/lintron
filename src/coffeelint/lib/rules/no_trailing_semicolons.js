// Generated by CoffeeScript 1.7.1
(function() {
  var NoTrailingSemicolons, regexes,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  regexes = {
    trailingSemicolon: /;\r?$/
  };

  module.exports = NoTrailingSemicolons = (function() {
    function NoTrailingSemicolons() {}

    NoTrailingSemicolons.prototype.rule = {
      name: 'no_trailing_semicolons',
      level: 'error',
      message: 'Line contains a trailing semicolon',
      description: "This rule prohibits trailing semicolons, since they are needless\ncruft in CoffeeScript.\n<pre>\n<code># This semicolon is meaningful.\nx = '1234'; console.log(x)\n\n# This semicolon is redundant.\nalert('end of line');\n</code>\n</pre>\nTrailing semicolons are forbidden by default."
    };

    NoTrailingSemicolons.prototype.lintLine = function(line, lineApi) {
      var endPos, first, hasNewLine, hasSemicolon, last, lineTokens, newLine, startCounter, startPos, stopTokens, tokenLen, _i, _ref, _ref1;
      lineTokens = lineApi.getLineTokens();
      tokenLen = lineTokens.length;
      stopTokens = ['TERMINATOR', 'HERECOMMENT'];
      if (tokenLen === 1 && (_ref = lineTokens[0][0], __indexOf.call(stopTokens, _ref) >= 0)) {
        return;
      }
      newLine = line;
      if (tokenLen > 1 && lineTokens[tokenLen - 1][0] === 'TERMINATOR') {
        startPos = lineTokens[tokenLen - 2][2].last_column + 1;
        endPos = lineTokens[tokenLen - 1][2].first_column;
        if (startPos !== endPos) {
          startCounter = startPos;
          while (line[startCounter] !== '#' && startCounter < line.length) {
            startCounter++;
          }
          newLine = line.substring(0, startCounter).replace(/\s*$/, '');
        }
      }
      hasSemicolon = regexes.trailingSemicolon.test(newLine);
      first = 2 <= lineTokens.length ? __slice.call(lineTokens, 0, _i = lineTokens.length - 1) : (_i = 0, []), last = lineTokens[_i++];
      hasNewLine = last && (last.newLine != null);
      if (hasSemicolon && !hasNewLine && lineApi.lineHasToken() && !((_ref1 = last[0]) === 'STRING' || _ref1 === 'IDENTIFIER' || _ref1 === 'STRING_END')) {
        return true;
      }
    };

    return NoTrailingSemicolons;

  })();

}).call(this);
