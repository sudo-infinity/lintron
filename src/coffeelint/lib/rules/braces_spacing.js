// Generated by CoffeeScript 1.7.1
(function() {
  var BracesSpacing;

  module.exports = BracesSpacing = (function() {
    function BracesSpacing() {}

    BracesSpacing.prototype.rule = {
      name: 'braces_spacing',
      level: 'ignore',
      spaces: 0,
      empty_object_spaces: 0,
      message: 'Curly braces must have the proper spacing',
      description: 'This rule checks to see that there is the proper spacing inside\ncurly braces. The spacing amount is specified by "spaces".\nThe spacing amount for empty objects is specified by\n"empty_object_spaces".\n\n<pre><code>\n# Spaces is 0\n{a: b}     # Good\n{a: b }    # Bad\n{ a: b}    # Bad\n{ a: b }   # Bad\n\n# Spaces is 1\n{a: b}     # Bad\n{a: b }    # Bad\n{ a: b}    # Bad\n{ a: b }   # Good\n{ a: b  }  # Bad\n{  a: b }  # Bad\n{  a: b  } # Bad\n\n# Empty Object Spaces is 0\n{}         # Good\n{ }        # Bad\n\n# Empty Object Spaces is 1\n{}         # Bad\n{ }        # Good\n</code></pre>\n\nThis rule is disabled by default.'
    };

    BracesSpacing.prototype.tokens = ['{', '}'];

    BracesSpacing.prototype.distanceBetweenTokens = function(firstToken, secondToken) {
      return secondToken[2].first_column - firstToken[2].last_column - 1;
    };

    BracesSpacing.prototype.findNearestToken = function(token, tokenApi, difference) {
      var nearestToken, totalDifference;
      totalDifference = 0;
      while (true) {
        totalDifference += difference;
        nearestToken = tokenApi.peek(totalDifference);
        if (nearestToken[0] === 'OUTDENT') {
          continue;
        }
        return nearestToken;
      }
    };

    BracesSpacing.prototype.tokensOnSameLine = function(firstToken, secondToken) {
      return firstToken[2].first_line === secondToken[2].first_line;
    };

    BracesSpacing.prototype.getExpectedSpaces = function(tokenApi, firstToken, secondToken) {
      var config, _ref;
      config = tokenApi.config[this.rule.name];
      if (firstToken[0] === '{' && secondToken[0] === '}') {
        return (_ref = config.empty_object_spaces) != null ? _ref : config.spaces;
      } else {
        return config.spaces;
      }
    };

    BracesSpacing.prototype.lintToken = function(token, tokenApi) {
      var actual, expected, firstToken, msg, secondToken, _ref;
      if (token.generated) {
        return null;
      }
      _ref = token[0] === '{' ? [token, this.findNearestToken(token, tokenApi, 1)] : [this.findNearestToken(token, tokenApi, -1), token], firstToken = _ref[0], secondToken = _ref[1];
      if (!this.tokensOnSameLine(firstToken, secondToken)) {
        return null;
      }
      expected = this.getExpectedSpaces(tokenApi, firstToken, secondToken);
      actual = this.distanceBetweenTokens(firstToken, secondToken);
      if (actual === expected) {
        return null;
      } else {
        msg = "There should be " + expected + " space";
        if (expected !== 1) {
          msg += 's';
        }
        msg += " inside \"" + token[0] + "\"";
        return {
          context: msg
        };
      }
    };

    return BracesSpacing;

  })();

}).call(this);
