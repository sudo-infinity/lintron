// Generated by CoffeeScript 1.7.1

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
CoffeeLint is freely distributable under the MIT license.
 */

(function() {
  var ASTLinter, CoffeeScript, ERROR, ErrorReport, IGNORE, LexicalLinter, LineLinter, RULES, WARN, cache, coffeelint, defaults, difference, extend, hasSyntaxError, mergeDefaultConfig, nodeRequire, packageJSON, _rules,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  coffeelint = exports;

  nodeRequire = require;

  if (typeof window !== "undefined" && window !== null) {
    CoffeeScript = window.CoffeeScript;
  }

  if (CoffeeScript == null) {
    CoffeeScript = require('coffee-script');
  }

  if (CoffeeScript == null) {
    throw new Error('Unable to find CoffeeScript');
  }

  packageJSON = require('./../package.json');

  coffeelint.VERSION = packageJSON.version;

  ERROR = 'error';

  WARN = 'warn';

  IGNORE = 'ignore';

  coffeelint.RULES = RULES = require('./rules.js');

  extend = function() {
    var destination, k, source, sources, v, _i, _len;
    destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (k in source) {
        v = source[k];
        destination[k] = v;
      }
    }
    return destination;
  };

  defaults = function(source, defaults) {
    return extend({}, defaults, source);
  };

  difference = function(a, b) {
    var j, _ref, _results;
    j = 0;
    _results = [];
    while (j < a.length) {
      if (_ref = a[j], __indexOf.call(b, _ref) >= 0) {
        _results.push(a.splice(j, 1));
      } else {
        _results.push(j++);
      }
    }
    return _results;
  };

  LineLinter = require('./line_linter.js');

  LexicalLinter = require('./lexical_linter.js');

  ASTLinter = require('./ast_linter.js');

  cache = null;

  mergeDefaultConfig = function(userConfig) {
    var config, rule, ruleConfig;
    config = {};
    for (rule in RULES) {
      ruleConfig = RULES[rule];
      config[rule] = defaults(userConfig[rule], ruleConfig);
    }
    return config;
  };

  coffeelint.invertLiterate = function(source) {
    var line, newSource, _i, _len, _ref;
    source = CoffeeScript.helpers.invertLiterate(source);
    newSource = "";
    _ref = source.split("\n");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      if (line.match(/^#/)) {
        line = line.replace(/\s*$/, '');
      }
      line = line.replace(/^\s{4}/g, '');
      newSource += "" + line + "\n";
    }
    return newSource;
  };

  _rules = {};

  coffeelint.registerRule = function(RuleConstructor, ruleName) {
    var e, name, p, _ref, _ref1;
    if (ruleName == null) {
      ruleName = void 0;
    }
    p = new RuleConstructor;
    name = (p != null ? (_ref = p.rule) != null ? _ref.name : void 0 : void 0) || "(unknown)";
    e = function(msg) {
      throw new Error("Invalid rule: " + name + " " + msg);
    };
    if (p.rule == null) {
      e("Rules must provide rule attribute with a default configuration.");
    }
    if (p.rule.name == null) {
      e("Rule defaults require a name");
    }
    if ((ruleName != null) && ruleName !== p.rule.name) {
      e("Mismatched rule name: " + ruleName);
    }
    if (p.rule.message == null) {
      e("Rule defaults require a message");
    }
    if (p.rule.description == null) {
      e("Rule defaults require a description");
    }
    if ((_ref1 = p.rule.level) !== 'ignore' && _ref1 !== 'warn' && _ref1 !== 'error') {
      e("Default level must be 'ignore', 'warn', or 'error'");
    }
    if (typeof p.lintToken === 'function') {
      if (!p.tokens) {
        e("'tokens' is required for 'lintToken'");
      }
    } else if (typeof p.lintLine !== 'function' && typeof p.lintAST !== 'function') {
      e("Rules must implement lintToken, lintLine, or lintAST");
    }
    RULES[p.rule.name] = p.rule;
    return _rules[p.rule.name] = RuleConstructor;
  };

  coffeelint.getRules = function() {
    var key, output, _i, _len, _ref;
    output = {};
    _ref = Object.keys(RULES).sort();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      output[key] = RULES[key];
    }
    return output;
  };

  coffeelint.registerRule(require('./rules/arrow_spacing.js'));

  coffeelint.registerRule(require('./rules/braces_spacing.js'));

  coffeelint.registerRule(require('./rules/no_tabs.js'));

  coffeelint.registerRule(require('./rules/no_trailing_whitespace.js'));

  coffeelint.registerRule(require('./rules/max_line_length.js'));

  coffeelint.registerRule(require('./rules/line_endings.js'));

  coffeelint.registerRule(require('./rules/no_trailing_semicolons.js'));

  coffeelint.registerRule(require('./rules/indentation.js'));

  coffeelint.registerRule(require('./rules/camel_case_classes.js'));

  coffeelint.registerRule(require('./rules/colon_assignment_spacing.js'));

  coffeelint.registerRule(require('./rules/no_implicit_braces.js'));

  coffeelint.registerRule(require('./rules/no_plusplus.js'));

  coffeelint.registerRule(require('./rules/no_throwing_strings.js'));

  coffeelint.registerRule(require('./rules/no_backticks.js'));

  coffeelint.registerRule(require('./rules/no_implicit_parens.js'));

  coffeelint.registerRule(require('./rules/no_empty_param_list.js'));

  coffeelint.registerRule(require('./rules/no_stand_alone_at.js'));

  coffeelint.registerRule(require('./rules/space_operators.js'));

  coffeelint.registerRule(require('./rules/duplicate_key.js'));

  coffeelint.registerRule(require('./rules/empty_constructor_needs_parens.js'));

  coffeelint.registerRule(require('./rules/cyclomatic_complexity.js'));

  coffeelint.registerRule(require('./rules/newlines_after_classes.js'));

  coffeelint.registerRule(require('./rules/no_unnecessary_fat_arrows.js'));

  coffeelint.registerRule(require('./rules/missing_fat_arrows.js'));

  coffeelint.registerRule(require('./rules/non_empty_constructor_needs_parens.js'));

  coffeelint.registerRule(require('./rules/no_unnecessary_double_quotes.js'));

  coffeelint.registerRule(require('./rules/no_debugger.js'));

  coffeelint.registerRule(require('./rules/no_interpolation_in_single_quotes.js'));

  coffeelint.registerRule(require('./rules/no_empty_functions.js'));

  coffeelint.registerRule(require('./rules/prefer_english_operator.js'));

  coffeelint.registerRule(require('./rules/spacing_after_comma.js'));

  coffeelint.registerRule(require('./rules/transform_messes_up_line_numbers.js'));

  coffeelint.registerRule(require('./rules/ensure_comprehensions.js'));

  hasSyntaxError = function(source) {
    try {
      CoffeeScript.tokens(source);
      return false;
    } catch (_error) {}
    return true;
  };

  ErrorReport = require('./error_report.js');

  coffeelint.getErrorReport = function() {
    return new ErrorReport(coffeelint);
  };

  coffeelint.lint = function(source, userConfig, literate) {
    var all_errors, astErrors, block_config, cmd, config, disabled, disabled_initially, e, errors, i, l, lexErrors, lexicalLinter, lineErrors, lineLinter, m, name, next_line, r, ruleLoader, rules, s, sourceLength, tokensByLine, transform, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    if (userConfig == null) {
      userConfig = {};
    }
    if (literate == null) {
      literate = false;
    }
    errors = [];
    try {
      ruleLoader = require('./ruleLoader');
      ruleLoader.loadFromConfig(this, userConfig);
    } catch (_error) {}
    if (cache != null) {
      cache.setConfig(userConfig);
    }
    if (cache != null ? cache.has(source) : void 0) {
      return cache != null ? cache.get(source) : void 0;
    }
    config = mergeDefaultConfig(userConfig);
    if (literate) {
      source = this.invertLiterate(source);
    }
    if ((userConfig != null ? (_ref = userConfig.coffeelint) != null ? _ref.transforms : void 0 : void 0) != null) {
      sourceLength = source.split("\n").length;
      _ref2 = userConfig != null ? (_ref1 = userConfig.coffeelint) != null ? _ref1.transforms : void 0 : void 0;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        m = _ref2[_i];
        transform = ruleLoader.require(m);
        source = transform(source);
      }
      if (sourceLength !== source.split("\n").length && config.transform_messes_up_line_numbers.level !== 'ignore') {
        errors.push(extend({
          lineNumber: 1,
          context: "File was transformed from " + sourceLength + " lines to " + (source.split("\n").length) + " lines"
        }, config.transform_messes_up_line_numbers));
        console.log(errors);
      }
    }
    if ((userConfig != null ? (_ref3 = userConfig.coffeelint) != null ? _ref3.coffeescript : void 0 : void 0) != null) {
      CoffeeScript = ruleLoader.require(userConfig.coffeelint.coffeescript);
    }
    for (name in userConfig) {
      if (name !== 'coffeescript_error' && name !== '_comment') {
        if (_rules[name] == null) {
          void 0;
        }
      }
    }
    disabled_initially = [];
    _ref4 = source.split('\n');
    for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
      l = _ref4[_j];
      s = LineLinter.configStatement.exec(l);
      if ((s != null ? s.length : void 0) > 2 && __indexOf.call(s, 'enable') >= 0) {
        _ref5 = s.slice(1);
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          r = _ref5[_k];
          if (r !== 'enable' && r !== 'disable') {
            if (!(r in config && ((_ref6 = config[r].level) === 'warn' || _ref6 === 'error'))) {
              disabled_initially.push(r);
              config[r] = {
                level: 'error'
              };
            }
          }
        }
      }
    }
    astErrors = new ASTLinter(source, config, _rules, CoffeeScript).lint();
    errors = errors.concat(astErrors);
    if (!hasSyntaxError(source)) {
      lexicalLinter = new LexicalLinter(source, config, _rules, CoffeeScript);
      lexErrors = lexicalLinter.lint();
      errors = errors.concat(lexErrors);
      tokensByLine = lexicalLinter.tokensByLine;
      lineLinter = new LineLinter(source, config, _rules, tokensByLine, literate);
      lineErrors = lineLinter.lint();
      errors = errors.concat(lineErrors);
      block_config = lineLinter.block_config;
    } else {
      block_config = {
        enable: {},
        disable: {}
      };
    }
    errors.sort(function(a, b) {
      return a.lineNumber - b.lineNumber;
    });
    all_errors = errors;
    errors = [];
    disabled = disabled_initially;
    next_line = 0;
    for (i = _l = 0, _ref7 = source.split('\n').length; 0 <= _ref7 ? _l < _ref7 : _l > _ref7; i = 0 <= _ref7 ? ++_l : --_l) {
      for (cmd in block_config) {
        rules = block_config[cmd][i];
        if (rules != null) {
          ({
            'disable': function() {
              return disabled = disabled.concat(rules);
            },
            'enable': function() {
              difference(disabled, rules);
              if (rules.length === 0) {
                return disabled = disabled_initially;
              }
            }
          })[cmd]();
        }
      }
      while (next_line === i && all_errors.length > 0) {
        next_line = all_errors[0].lineNumber - 1;
        e = all_errors[0];
        if (e.lineNumber === i + 1 || (e.lineNumber == null)) {
          e = all_errors.shift();
          if (_ref8 = e.rule, __indexOf.call(disabled, _ref8) < 0) {
            errors.push(e);
          }
        }
      }
    }
    if (cache != null) {
      cache.set(source, errors);
    }
    return errors;
  };

  coffeelint.setCache = function(obj) {
    return cache = obj;
  };

}).call(this);
